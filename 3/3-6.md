# GitHub Actions
- GitHub Actions는 DevOps의 핵심 중 하나인 **CI/CD(지속적 통합 / 지속적 배포)** 를 쉽게 구현할 수 있도록 도와주는 GitHub의 자동화 도구다.

## GitHub Actions의 특징
DevOps에서 자동화는 핵심이다.
- GitHub과 자연스럽게 통합됨
- 서버 없이 CI/CD를 바로 구축 가능
- 워크플로우 정의만으로 자동화 가능 (YAML)
- 다양한 외부 서비스와 연동 가능 (DockerHub, Slack, AWS 등)
- 무료 사용량 제공 (퍼블릭 저장소 또는 소규모 프로젝트에 적합)

## CI/CD란 무엇인가?

| 용어                                    | 설명                                          |
| ------------------------------------- | ------------------------------------------- |
| CI (Continuous Integration)           | 코드가 변경될 때마다 **자동으로 빌드/테스트**하여 문제를 조기에 발견    |
| CD (Continuous Delivery / Deployment) | 빌드된 애플리케이션을 **자동으로 배포** (배포 단계까지 완전 자동화 가능) |

개발 → 빌드 → 테스트 → 배포까지 자동으로 이어지는 흐름을 만드는 것이 DevOps의 목표다.

## GitHub Actions 작동 원리
GitHub Actions는 다음과 같은 구조로 동작한다.

```yaml
- Workflow: 자동화의 전체 흐름
  - Trigger (on): 실행 조건 (push, pull_request, schedule 등)
  - Jobs: 병렬 또는 순차 작업 단위
    - Steps: 각 작업 안에서 실제 실행되는 명령들
      - Action: 재사용 가능한 모듈 (예: `checkout`, `setup-java`)
```

`.github/workflows/ci.yml` 같은 YAML 파일에 정의한다.

## GitHub Actions 구성 예시

### Java(Spring Boot) 프로젝트 자동 빌드 + DockerHub 푸시 + EC2 배포
```yaml
# 워크플로우 이름 설정
name: Spring Boot CI/CD

# 워크플로우 실행 조건 설정
on:
  push:
    branches: [ "main" ]          # main 브랜치에 push 시 실행
  pull_request:
    branches: [ "main" ]          # main 브랜치로 PR 생성 시 실행

jobs:
  build:
    runs-on: ubuntu-latest        # GitHub에서 제공하는 Ubuntu 최신 가상 환경에서 실행

    steps:
    # 1. 현재 GitHub Repository 코드 체크아웃
    - uses: actions/checkout@v4

    # 2. JDK 21 설정 (Temurin 배포판 사용, Maven 캐시 활성화)
    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'            # 사용할 Java 버전
        distribution: 'temurin'       # JDK 배포판
        cache: maven                  # Maven 의존성 캐시 사용으로 빌드 속도 향상

    # 3. Docker 이미지 빌드 (현재 디렉토리의 Dockerfile 기준)
    - name: docker image build
      run: docker build -t ${{ secrets.DOCKERHUB_USERNAME}}/spring-boot-app1 .

    # 4. DockerHub 로그인
    - name: Docker login
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}   # GitHub Secrets에 저장된 DockerHub 사용자명
        password: ${{ secrets.DOCKERHUB_PASSWORD }}   # GitHub Secrets에 저장된 DockerHub 비밀번호

    # 5. DockerHub에 이미지 푸시
    - name: Docker Hub image push
      run: docker push ${{ secrets.DOCKERHUB_USERNAME }}/spring-boot-app1

    # 6. EC2 개인 키 복호화 및 권한 설정
    - name: Decode and save private key
      run: |
        echo "${{ secrets.EC2_PRIVATE_KEY }}" > ec2_key.pem    # 개인키 파일 생성
        chmod 600 ec2_key.pem                                  # SSH 접속을 위한 안전한 권한 설정

    # 7. EC2 서버에 SSH 접속 후 원격 배포 스크립트 실행
    - name: Deploy to EC2
      run: |
        ssh -o StrictHostKeyChecking=no -i ec2_key.pem ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} << 'EOF'
          # (선택사항) DockerHub 로그인 명령. 비활성화 되어 있음
          # docker login -u ${{ secrets.DOCKERHUB_USERNAME }} -p ${{ secrets.DOCKERHUB_TOKEN }}

          # 최신 이미지 가져오기
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/spring-boot-app1:latest

          # 실행 중인 컨테이너가 있으면 중지 및 삭제
          docker stop app-container || true
          docker rm app-container || true

          # 새 컨테이너 실행 (8080 포트 매핑)
          docker run -d --name app-container -p 8080:8080 ${{ secrets.DOCKERHUB_USERNAME }}/spring-boot-app1:latest
        EOF

```

### GitHub Secrets 설정 (보안 처리)
- `DOCKERHUB_USERNAME`: DockerHub ID
- `DOCKERHUB_PASSWORD`: DockerHub Password
- `EC2_HOST`: EC2 퍼블릭 IP
- `EC2_USERNAME`: 접속 계정 (예: ec2-user)
- `EC2_PRIVATE_KEY`: EC2 SSH 키 (.pem 파일 내용 전체)

> Secrets는 GitHub Repository → Settings → Secrets → Actions 메뉴에서 등록

### 실습 흐름 요약 (Spring Boot 프로젝트 기준)
- 코드 수정 및 **GitHub에 Push**
- `.github/workflows/ci.yml`에 정의된 Workflow 작동
- Maven 또는 Docker 빌드 수행
- DockerHub에 이미지 Push
- EC2 원격 접속 → 기존 컨테이너 종료 및 재배포